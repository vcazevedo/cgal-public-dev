namespace CGAL {
/*!

\mainpage User Manual 
\anchor Chapter_3D_Mean_Curvature_Skeleton

\cgalAutoToc
\author Xiang Gao and Andrea Tagliasacchi

\section MCFSkelSecMot Introduction

\cgalFigureBegin{Main_image_suggestion, main_image_suggestion.png}
Mean curvature flow skeleton of a horse model.
\cgalFigureEnd

Skeletons are effective shape abstractions commonly used in reconstruction, segmentation, shape matching, virtual navigation... In this package, we implement the algorithm described in \cgalCite{tagliasacchi2012mean}, which extracts a curve skeleton from a watertight surface mesh. A curve skeleton is a pure 1D structure while a medial axis skeleton consists of 2D surfaces and 1D curves.  Even if of a lower dimension, the curve skeleton still captures the essential topology of the shape.

\section MCFSkelSecAlgo Algorithm Description

<em>Mean curvature flow</em> (MCF) is a motion of each surface point along its anti-normal direction with a speed proportional to its mean curvature.  MCF minimizes the membrane energy of a surface, which measures the surface area \cgalCite{botsch2010polygon}. The area minimizing property makes MCF an ideal candidate for the core of a skeletonization algorithm. In \cgalCite{tagliasacchi2012mean}, the authors prove the anisotropic property of MCF, which implies the triangles in the contracted mesh are along the low principle curvature direction. This further justifies the use of MCF in skeletonization.

The input of our skeletonization algorithm is a watertight manifold triangle mesh. If the user wants to get a medially centered skeleton, the Voronoi poles are used. These poles are known to lie on the medial axis when the surface is sufficiently well-sampled. The main algorithm involves iterative MCF based contractions. In each iteration, the mesh is contracted by MCF, then local remeshing and degeneracy detection is performed. The iterations stop when the area of the contracted mesh vanishes. To detect convergence, our algorithm compares the change of surface area after one iteration with the original area, if it is less than \f$ delta\_area \times original\_area\f$, the main iteration stops. The change from a contracted surface mesh to a curve skeleton is done by iteratively collapsing short edges until all the faces have been collapsed, which gives a 1D curve skeleton. The flowchart of the algorithm is shown in \cgalFigureRef{Flowchart}. In the remaining of this section, we describe the details of each step in the iteration.

\cgalFigureBegin{Flowchart, flowchart.png}
A flow chart of the main algorithm.
\cgalFigureEnd

\subsection MCFSkelSecContra Mesh Contraction via Mean Curvature Flow

We formulate the MCF in an implicit form with discrete Laplacian operator \f$ L \f$. Since the Laplacian equation \f$ LV = 0 \f$ has a trivial solution, the following regularized version is considered instead:

\f[
\begin{equation}
  \left[\begin{array}{c}
  L\\
  W_{H}
  \end{array}\right] 
  V^{t+1} = 
  \left[\begin{array}{c}
  0\\
  W_{H}V^{t}
  \end{array}\right] 
  \label{eq:regularized_equation}
\end{equation}
\f]

\f$ V^{t} \f$ is the vertex embedding in iteration \f$ t \f$. \f$ L \f$ we use here is the classic cotangent Laplacian operator introduced in \cgalCite{desbrun1999implicit}. \f$ W_{H} \f$ is a diagonal matrix, all diagonal element being equal and denoted as \f$ w_{H}\f$.  \f$w_{H}\f$ is a user parameter that controls the speed of MCF. Slowing down the MCF is essential since as the mesh evolves, the local curvature changes and the Laplacian operator needs to be updated to better approximate the mean curvature.

The effect of \f$ w_{H} \f$ is illustrated in \cgalFigureRef{WHeffect}.

\cgalFigureBegin{WHeffect, WHeffect.png}
From left to right, the \f$ w_{H} \f$ is 0.1, 0.05, 0.01, 0.005 respectively.  Note setting \f$ w_{H} \f$ too small results in a low quality of skeleton.  By default, the \f$ w_{H} \f$ is set to 0.1, which works well in most cases.
\cgalFigureEnd

\subsection MCFSkelSecRemesh Local Dynamic Remeshing

As shown in \cgalCite{tagliasacchi2012mean}, the MCF moves the surface points along the maximum principle curvature directions, which could result in very high aspect ratio triangles that stiffens the finite element solver. To address the problem, a local remeshing is performed at each iteration by collapsing short edges and split badly triangles while maintaining the manifold property.  Specifically, an edge \f$ e \f$ is split if in an incident triangle, the angle at the opposite vertex in the triangle is greater than \f$ 110^{\circ} \f$. The split point is the perpendicular projection of the opposite vertex onto \f$ e \f$.

\subsection MCFSkelSecDegeneracy Degeneracy Detection

As the mesh contraction process continues, the collapsed branches of the shape would be pulled away from the medial axis and the tips of the skeletal branches could be contracted back into the shape. We would like to stop the movement of points in a branch when a branch is detected. If we think of a branch as infinitesimal cross-sectional manifold, in the discrete case the problem is reduced to monitor the Euler characteristic of a point within a infinitesimal geodesic neighborhood. If the local neighborhood exhibits non-disk topology, we think the point is degenerate and fix it by setting the correspondent diagonal element in \f$ W_{H} \f$ as a very large number.

\subsection MCFSkelSecMedial Medial Skeletonization Flow

To compute a well-centered curve skeleton (i.e. one that lies close to the medial axis) we modify Eq.\f$\eqref{eq:regularized_equation}\f$ to:

\f[
\begin{equation}
  \left[\begin{array}{c}
  L\\
  W_{H}\\
  W_{P}
  \end{array}\right] 
  V^{t+1} = 
  \left[\begin{array}{c}
  0\\
  W_{H}V^{t}\\
  W_{P}P^{t}
  \end{array}\right] 
  \label{eq:medial_equation}
\end{equation}
\f]

Where the \f$ W_{P} \f$ is weights to control the smoothness of medial approximation and \f$ P^{t} \f$ is correspondent medial poles for each vertex.  During the collapse in local remeshing, we need to update the pole. In particular, we position the new vertex to the middle point of the collapsed edge and choose the closest pole from the poles of the two incident vertices of the edge.

\note To solve the spares linear system, Eigen 3.2 or later is recommended. Eigen is an open source library and easy to use.

\section MCFSkelSecAPI User Interface Description

The MCF skeleton and the MCF medial skeleton can be obtained by respectively using the free functions 
`::CGAL::extract_skeleton()`.
The class `::CGAL::MCF_Skeleton` is also provided to allow advanced usage and having access to each step of the contraction.

It is also possible to get the correspondence between skeleton points and input vertices.

The correspondent points for a skeletal vertex are original surface points that are collapsed onto the skeletal vertex. They are useful for tasks such as mesh segmentation. In \cgalFigureRef{Correspondence}, we visualize such relationship by connecting each skeletal point to its correspondent points.

\cgalFigureBegin{Correspondence, correspondence.png}
Every skeletal point is connected to its correspondent surface points.
\cgalFigureEnd

As a proof of concept, we show an example of doing mesh segmentation with the skeleton extracted by this package. In the Mesh Segmentation package from CGAL, the first step is computing a shape diameter value, and the second step is solving a graph cut problem. Here we use our skeleton to compute the the shape diameter value. Specifically we compute the diameter value for each surface point as the distance between it and its corresponding skeletal point. Then we plug the diameter values into the graph cut algorithm from Segmentation package to get a continuous mesh segmentation. We show a sample segmentation in \cgalFigureRef{Segmentation}.

\cgalFigureBegin{Segmentation, segmentation.png}
On the left is the curve skeleton extracted from the mesh. On the right is the segmentation result utilizing the skeleton.
\cgalFigureEnd

\note Due to the remeshing step (the edge split) in the algorithm, a given skeleton point might have no corresponding surface point.

\subsection Skeletonization Examples

\subsubsection Example_1 Extract Skeleton Without Correspondence Tracking

In this example, we only extract the curve skeleton and outputs the embedding of the skeletal points.

\cgalExample{Mean_curvature_skeleton/simple_mcfskel_example.cpp}

\subsubsection Example_2 Extract Skeleton With Correspondence Tracking

In this example, we extract the skeleton with correspondent points. Then we show how to access the correspondent points for each skeletal point.

\cgalExample{Mean_curvature_skeleton/extract_correspondence_example.cpp}

\section MCFSkelSecDesign Design and Implementation History

The initial implementation of this package is the result of the work of Xiang Gao during the 2013 season of the Google Summer of Code mentored by Andrea Tagliasacchi and SÃ©bastien Loriot.

*/ 
} /* namespace CGAL */

