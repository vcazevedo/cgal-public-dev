namespace CGAL {
/*!

\mainpage User Manual 
\anchor Chapter_3D_Mean_Curvature_Skeleton

\cgalAutoToc
\author Xiang Gao and Andrea Tagliasacchi

\section MCFSkelSecMot Introduction

\cgalFigureBegin{Main_image_suggestion, main_image_suggestion.png}
Skeletonization results for the horse model. 
\cgalFigureEnd

Skeletons are effective shape abstractions commonly used in reconstruction, 
segmentation, shape matching and virtual navigation. In this package, we 
implement the algorithm described in \cgalCite{tagliasacchi2012mean}, which extracts
a curve skeleton from a watertight surface mesh. The curve skeleton is a pure 1D
structure, compared with the medial axis skeleton which consists of 2D surfaces
and 1D curves. With a lower dimensionality, the curve skeleton still captures 
the essential topology of the shape: With a curve skeleton and a radius 
function, a shape approximation can be generated.

\section MCFSkelSecAlgo Algorithm Description

Mean curvature flow (MCF) is a motion that moves each surface point along its
anti-normal direction with speed proportional with its mean curvature.

\f[
\begin{equation}
\dot{S} = -H\mathbf{n} ~~~ H = (k1 + k2) / 2
  \label{eq:MCF}
\end{equation}
\f]

It is shown that MCF minimizes the membrane energy of a surface, which measures
the surface area \cgalCite{botsch2010polygon}. The area minimizing property makes MCF
an ideal candidate for the core of a skeletonization algorithm. In 
\cgalCite{tagliasacchi2012mean}, the authors prove the anisotropic property of MCF,
which implies the triangles in the contracted mesh are along the low principle 
curvature direction. This further justifies the use of MCF in skeletonization.

\subsection MCFSkelSecContra Iterative Mesh Contraction via Mean Curvature Flow

We formulate the MCF in an implicit form with discrete Laplaceian operator 
\f$ L \f$. Since the Laplacian equation \f$ LV = 0 \f$ has a trivial solution,
we solve a regularized version:

\f[
\begin{equation}
  \left[\begin{array}{c}
  L\\
  W_{H}
  \end{array}\right] 
  V^{t+1} = 
  \left[\begin{array}{c}
  0\\
  W_{H}V^{t}
  \end{array}\right] 
  \label{eq:regularized_equation}
\end{equation}
\f]

\f$ W_{H} \f$ is a diagonal matrix in which \f$ W_{H,i} = w_{H}\f$. \f$w_{H}\f$
is a user supplied parameter to control the speed of MCF. Slowing down the MCF
is essential since as the mesh evolves, the local curvature changes and the 
Laplacian operator needs to be updated to better approximate the mean curvature.

The effect of \f$ w_{H} \f$ can be illustrated in \cgalFigureRef{WHeffect}.

\cgalFigureBegin{WHeffect, WHeffect.png}
From left to right, the \f$ w_{H} \f$ is 0.1, 0.05, 0.01, 0.005 respectively.
Note setting \f$ w_{H} \f$ too small results in a low quality of skeleton.
\cgalFigureEnd

\subsection MCFSkelSecRemesh Local Dynamic Remeshing

As shown in \cgalCite{tagliasacchi2012mean}, the MCF moves the surface points along
the max principle curvature directions, which could result in very high aspect
ratio triangles that stiffens the finite element solver. To address the problem,
a local remeshing is performed at each iteration to collapse too short edges 
and split badly triangles while maintaing the manifold property. Specifically we
split triangles at the edge \f$ e \f$ if its opposite angle is greater than 
\f$ 110^{\circ} \f$. To determine the split point, we heuristically project the
opposite vertex onto \f$ e \f$. \cgalFigureRef{Flowchart} shows the split 
process.

\cgalFigureBegin{Split, split.png}
\cgalFigureEnd

\subsection MCFSkelSecDegeneracy Degeneracy Detection

As the mesh contraction process continues, the collapsed branches of the shape
would be pulled away from the medial axis aand the tips of the skeletal branches
could be contracted back into the shape. We would like to stop the movement of 
points in a branch when a branch is detected. If we think of a branch as 
infinitesimal cross-sectional manifold, in the discrete case the problem is 
reduced to monitor the euler characteristic of a point within a infinitesimal
geodesic neighborhood. If the local neighborhood exhibits non-disk topology, we
think the point is degenerate and fix it by setting the correspondent diagonal
element in \f$ W_{H} \f$ as a very large number.

\subsection MCFSkelSecMedial Medial Skeletonization Flow

To compute a well-centered curve skeleton (i.e. one that lies on the medial 
axis) we modify Eq.\f$\eqref{eq:regularized_equation}\f$ to:

\f[
\begin{equation}
  \left[\begin{array}{c}
  L\\
  W_{H}\\
  W_{P}
  \end{array}\right] 
  V^{t+1} = 
  \left[\begin{array}{c}
  0\\
  W_{H}V^{t}\\
  W_{P}P^{t}
  \end{array}\right] 
  \label{eq:medial_equation}
\end{equation}
\f]

Where the \f$ W_{P} \f$ is weights to control the smoothness of medial 
approximation and \f$ P^{t} \f$ is correspondent medial poles for each vertex. 
During the collapse in local remeshing, we need to update the pole. In 
particular, we position the new vertex to the middle point of the collapsed edge
and choose the closest pole from the poles of the two incident vertices of the 
edge.

\subsection MCFSkelSecSummary Summary

The algorithm runs iteratively. In each iteration, the mesh contraction by MCF,
local remeshing and degeneracy detection is performed. The work flow of our 
algorithm is illustrated in \cgalFigureRef{Flowchart}.

The input of our skeletonization algorithm is a watertight manifold triangle mesh.
If the user wants to get a medially centered skeleton, the Voronoi poles are 
computed. These poles are known to lie on the medial axis when the surface is
sufficiently well-sampled. 

The algorithm stops when the area of the contracted mesh vanishes. To detect 
convergence, our algorithm compares the change of surface area after one 
iteration with the original area, if it is less than 
\f$ area\_TH \times original\_area\f$, the main iteration stops. The change 
from a contracted surface mesh to a curve skeleton is done by iteratively 
collapsing short edges until all the faces have been collapsed, which gives a 
1D curve skeleton.

\cgalFigureBegin{Flowchart, flowchart.png}
A flow chart of the main algorithm.
\cgalFigureEnd

\section MCFSkelSecAPI API Description

This package provides the skeletonization function through a class object.

  - `Mean_curvature_skeleton(polyhedron, vertex_index_map, edge_index_map, omega_H, omega_P, edgelength_TH, is_medially_centered, area_TH = 1e-5, iteration_TH = 500)`

  - `vertex_index_map` and `edge_index_map` are property maps used for assigning
  indices to vertices and edges. 

  - `omega_H` controls the velocity of movement and approximation quality.

  - `omega_P` controls the smoothness of the medial approximation.

  - `edgelength_TH` controls the length of edges that will be collapsed in local
  remeshing.

  - `is_medially_centered` set to true means the skeleton extracted is medially
  centered.

  - `area_TH` controls the convergence criteria.

  - `iteration_TH` sets a maximum number of iterations. It is useful when the 
  `area_TH` is set so small that the algorithm cannot terminate in a reasonable
  time.

The extraction of skeleton can be done by calling the member function:

  - `extract_skeleton(graph, points)`

  - `graph` is a `boost::graph` data structure containing the connectivity 
  information of the curve skeleton.

  - `points` contains the embedding of the skeletal points.

It is also possible to get the correspondent points by calling

  - `extract_skeleton(graph, points, correspondent_points)`

  - `correspondent_points` contains the correspondent points for each skeletal
  points.

The correspondent points for a skeletal vertex are original surface points that
are collapsed onto the skeletal vertex. They are useful for tasks such as mesh
segmentation. In \cgalFigureRef{Correspondence}, we visualize such relationship
by connecting each skeletal point to its correspondent points.

\cgalFigureBegin{Correspondence, correspondence.png}
Every skeletal point is connected to its correspondent surface points.
\cgalFigureEnd

\note It could happen that a given skeletal point does not have correspondent
surface points. Recall the correspondent points for a give point are original
surface points collapsed onto it during local remeshing. If there are no points
collapsed onto the given point, or points collapsed onto it do not belong to
the original surface (they are actually new points generated in the split process in local remeshing), in the end the given point will have no correspondent 
points.

\subsection Skeletonization Examples

\subsubsection Example_1 Extract Skeleton Without Correspondence Tracking

In this example, we only extract the curve skeleton and outputs the embedding 
of the skeletal points.

\cgalExample{Mean_curvature_skeleton/simple_mcfskel_example.cpp}

\subsubsection Example_2 Extract Skeleton With Correspondence Tracking

In this example, we extract the skeleton with correspondent points. Then we 
show how to access the correspondent points for each skeletal point.

\cgalExample{Mean_curvature_skeleton/extract_correspondence_example.cpp}

\section MCFSkelSecDesign Implementation History

The initial implementation of this package is the result of the work of Xiang
during the 2013 season of the Google Summer of Code mentored by Andrea
Tagliasacchi and SÃ©bastien Loriot.

*/ 
} /* namespace CGAL */

