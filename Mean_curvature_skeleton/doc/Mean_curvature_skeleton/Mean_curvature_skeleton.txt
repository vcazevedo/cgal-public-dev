namespace CGAL {
/*!

\mainpage User Manual 
\anchor Chapter_3D_Mean_Curvature_Skeleton

\cgalAutoToc
\author Xiang Gao and Andrea Tagliasacchi

\section MCFSkelSecMot Introduction

\cgalFigureBegin{Main_image_suggestion, main_image_suggestion.png}
Mean curvature flow skeleton of a horse model.
\cgalFigureEnd

Skeletons are effective shape abstractions commonly used in reconstruction, 
segmentation, shape matching, virtual navigation... In this package, we 
implement the algorithm described in \cgalCite{tagliasacchi2012mean}, which extracts
a curve skeleton from a watertight surface mesh. A curve skeleton is a pure 1D
structure while a medial axis skeleton consists of 2D surfaces and 1D curves.
Even if of a lower dimension, the curve skeleton still captures 
the essential topology of the shape.

\section MCFSkelSecAlgo Algorithm Description

<em>Mean curvature flow</em> (MCF) is a motion of each surface point along its
anti-normal direction with a speed proportional to its mean curvature.

\f[
\begin{equation}
\dot{S} = -H\mathbf{n} ~~~ H = (k1 + k2) / 2
  \label{eq:MCF}
\end{equation}
\f]

\todo Is the equation bringing something to the description?

MCF minimizes the membrane energy of a surface, which measures
the surface area \cgalCite{botsch2010polygon}. The area minimizing property makes MCF
an ideal candidate for the core of a skeletonization algorithm. In 
\cgalCite{tagliasacchi2012mean}, the authors prove the anisotropic property of MCF,
which implies the triangles in the contracted mesh are along the low principle 
curvature direction. This further justifies the use of MCF in skeletonization.

The algorithm runs iteratively. In each iteration, the mesh is contracted by MCF,
local remeshing and degeneracy detection is performed.

\todo we say nothing about the skeleton extraction from the converged contracted mesh?

\subsection MCFSkelSecContra Iterative Mesh Contraction via Mean Curvature Flow

We formulate the MCF in an implicit form with discrete Laplacian operator 
\f$ L \f$. Since the Laplacian equation \f$ LV = 0 \f$ has a trivial solution,
the following regularized version is considered instead:

\f[
\begin{equation}
  \left[\begin{array}{c}
  L\\
  W_{H}
  \end{array}\right] 
  V^{t+1} = 
  \left[\begin{array}{c}
  0\\
  W_{H}V^{t}
  \end{array}\right] 
  \label{eq:regularized_equation}
\end{equation}
\f]

\todo the fact that the method is an iterative contraction is not mentioned (Well only in the section title).

\todo what are \f$ V \f$ , \f$ V^{t+1} \f$. Explain how \f$ L \f$ is constructed or refer to a paper

\f$ W_{H} \f$ is a diagonal matrix, all diagonal element being equal and denoted as  \f$ w_{H}\f$.
\f$w_{H}\f$ is a user parameter that controls the speed of MCF. Slowing down the MCF
is essential since as the mesh evolves, the local curvature changes and the 
Laplacian operator needs to be updated to better approximate the mean curvature.

The effect of \f$ w_{H} \f$ is illustrated in \cgalFigureRef{WHeffect}.

\cgalFigureBegin{WHeffect, WHeffect.png}
From left to right, the \f$ w_{H} \f$ is 0.1, 0.05, 0.01, 0.005 respectively.
Note setting \f$ w_{H} \f$ too small results in a low quality of skeleton.
\cgalFigureEnd

\todo Give the range of possible values for \f$ w_H \f$ with a guess on how to set it

\subsection MCFSkelSecRemesh Local Dynamic Remeshing

As shown in \cgalCite{tagliasacchi2012mean}, the MCF moves the surface points along
the maximum principle curvature directions, which could result in very high aspect
ratio triangles that stiffens the finite element solver. To address the problem,
a local remeshing is performed at each iteration by collapsing short edges 
and split badly triangles while maintaining the manifold property. 
Specifically, an edge \f$ e \f$ is split if in an incident triangle,
the angle at the opposite vertex in the triangle is greater than 
\f$ 110^{\circ} \f$. The split point is the projection of the
opposite vertex onto \f$ e \f$. \cgalFigureRef{Flowchart} illustrates shows the split 
process.

\todo how is the projection done? bissector?

\cgalFigureBegin{Split, split.png}
\cgalFigureEnd

\subsection MCFSkelSecDegeneracy Degeneracy Detection

As the mesh contraction process continues, the collapsed branches of the shape
would be pulled away from the medial axis and the tips of the skeletal branches
could be contracted back into the shape. We would like to stop the movement of 
points in a branch when a branch is detected. If we think of a branch as 
infinitesimal cross-sectional manifold, in the discrete case the problem is 
reduced to monitor the Euler characteristic of a point within a infinitesimal
geodesic neighborhood. If the local neighborhood exhibits non-disk topology, we
think the point is degenerate and fix it by setting the correspondent diagonal
element in \f$ W_{H} \f$ as a very large number.

\subsection MCFSkelSecMedial Medial Skeletonization Flow

To compute a well-centered curve skeleton (i.e. one that lies close to the medial 
axis) we modify Eq.\f$\eqref{eq:regularized_equation}\f$ to:

\f[
\begin{equation}
  \left[\begin{array}{c}
  L\\
  W_{H}\\
  W_{P}
  \end{array}\right] 
  V^{t+1} = 
  \left[\begin{array}{c}
  0\\
  W_{H}V^{t}\\
  W_{P}P^{t}
  \end{array}\right] 
  \label{eq:medial_equation}
\end{equation}
\f]

Where the \f$ W_{P} \f$ is weights to control the smoothness of medial 
approximation and \f$ P^{t} \f$ is correspondent medial poles for each vertex. 
During the collapse in local remeshing, we need to update the pole. In 
particular, we position the new vertex to the middle point of the collapsed edge
and choose the closest pole from the poles of the two incident vertices of the 
edge.

\subsection MCFSkelSecSummary Summary


The work flow of our algorithm is illustrated in \cgalFigureRef{Flowchart}.

The input of our skeletonization algorithm is a watertight manifold triangle mesh.
If the user wants to get a medially centered skeleton, the Voronoi poles are 
computed. These poles are known to lie on the medial axis when the surface is
sufficiently well-sampled. 

The algorithm stops when the area of the contracted mesh vanishes. To detect 
convergence, our algorithm compares the change of surface area after one 
iteration with the original area, if it is less than 
\f$ area\_TH \times original\_area\f$, the main iteration stops. The change 
from a contracted surface mesh to a curve skeleton is done by iteratively 
collapsing short edges until all the faces have been collapsed, which gives a 
1D curve skeleton.

\cgalFigureBegin{Flowchart, flowchart.png}
A flow chart of the main algorithm.
\cgalFigureEnd

\todo I would put the diagram in the algorithm section and use English and not function names. If the function name chosen are
obvious, the advanced class could be used without trouble.
The level of details we are looking for in a user manual is to give an idea to the user how things are working
and how parameters might influence the result of the functions they use

\section MCFSkelSecAPI User Interface Description

The MCF skeleton and the MCF medial skeleton can be obtained by respectively using the free functions 
`::CGAL::extract_skeleton()` and `::CGAL::extract_medial_skeleton()`.
The class `::CGAL::Mean_curvature_skeleton` is also provided to allow advanced usage and having access to each step of the contraction.

It is also possible to get the correspondence between skeleton points and input vertices.

\todo say something about the sparse linear solver and that we recommend to use Eigen 3.2 or later.

The correspondent points for a skeletal vertex are original surface points that
are collapsed onto the skeletal vertex. They are useful for tasks such as mesh
segmentation. In \cgalFigureRef{Correspondence}, we visualize such relationship
by connecting each skeletal point to its correspondent points.

\cgalFigureBegin{Correspondence, correspondence.png}
Every skeletal point is connected to its correspondent surface points.
\cgalFigureEnd

\todo I think it would be a good idea to provide the example using the segmentation algorithm function.
I would not inline the example in the doc (just put a like to the file) but put a picture.
The rational is that people always they are application but never show one. This is a concrete case.

\note Due to the remeshing step (the edge split) in the algorithm, a given skeleton point might have no corresponding surface point.

\subsection Skeletonization Examples

\subsubsection Example_1 Extract Skeleton Without Correspondence Tracking

In this example, we only extract the curve skeleton and outputs the embedding 
of the skeletal points.

\cgalExample{Mean_curvature_skeleton/simple_mcfskel_example.cpp}

\subsubsection Example_2 Extract Skeleton With Correspondence Tracking

In this example, we extract the skeleton with correspondent points. Then we 
show how to access the correspondent points for each skeletal point.

\cgalExample{Mean_curvature_skeleton/extract_correspondence_example.cpp}

\section MCFSkelSecDesign Design and Implementation History

The initial implementation of this package is the result of the work of Xiang Gao
during the 2013 season of the Google Summer of Code mentored by Andrea
Tagliasacchi and SÃ©bastien Loriot.

*/ 
} /* namespace CGAL */

