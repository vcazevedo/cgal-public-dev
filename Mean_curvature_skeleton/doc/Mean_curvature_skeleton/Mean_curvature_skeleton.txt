namespace CGAL {
/*!

\mainpage User Manual 
\anchor Chapter_3D_Mean_Curvature_Skeleton

\cgalAutoToc
\author Xiang Gao and Andrea Tagliasacchi

\section MCFSkelSecMot Introduction

\cgalFigureBegin{Main_image_suggestion, main_image_suggestion.png}
Mean curvature flow skeleton of a horse model.
\cgalFigureEnd

Skeletons are effective shape abstractions commonly used in reconstruction, segmentation, shape matching, virtual navigation... In this package, we implement the algorithm described in \cgalCite{tagliasacchi2012mean}, which extracts a curve skeleton from a watertight surface mesh. A curve skeleton is a pure 1D structure while a medial axis skeleton consists of 2D surfaces and 1D curves.  Even if of a lower dimension, the curve skeleton still captures the essential topology of the shape.

\section MCFSkelSecAlgo Algorithm Description

<em>Mean curvature flow</em> (MCF) is a motion of each surface point along its anti-normal direction with a speed proportional to its mean curvature.  MCF minimizes the membrane energy of a surface, which measures the surface area \cgalCite{botsch2010polygon}. The area minimizing property makes MCF an ideal candidate for the core of a skeletonization algorithm. In \cgalCite{tagliasacchi2012mean}, the authors prove the anisotropic property of MCF, which implies the triangles in the contracted mesh are along the low principle curvature direction. This further justifies the use of MCF in skeletonization.

The input of our skeletonization algorithm is a watertight manifold triangle mesh. If the user wants to get a medially centered skeleton, the Voronoi poles are used. These poles are known to lie on the medial axis when the surface is sufficiently well-sampled. The main algorithm involves iterative MCF based contractions. In each iteration, the mesh is contracted by MCF, then local remeshing and degeneracy detection is performed. The iterations stop when the area of the contracted mesh vanishes. To detect convergence, our algorithm compares the change of surface area after one iteration with the original area, if it is less than \f$ delta\_area \times original\_area\f$, the main iteration stops. The change from a contracted surface mesh to a curve skeleton is done by iteratively collapsing short edges until all the faces have been collapsed, which gives a 1D curve skeleton. The flowchart of the algorithm is shown in \cgalFigureRef{Flowchart}. In the remaining of this section, we describe the details of each step in the iteration.

\cgalFigureBegin{Flowchart, flowchart.png}
A flow chart of the main algorithm.
\cgalFigureEnd

\subsection MCFSkelSecContra Mesh Contraction via Mean Curvature Flow

We formulate the MCF in an implicit form with discrete Laplacian operator \f$ L \f$. Since the Laplacian equation \f$ LV = 0 \f$ has a trivial solution, the following regularized version is considered instead:

\f[
\begin{equation}
  \left[\begin{array}{c}
  L\\
  W_{H}
  \end{array}\right] 
  V^{t+1} = 
  \left[\begin{array}{c}
  0\\
  W_{H}V^{t}
  \end{array}\right] 
  \label{eq:regularized_equation}
\end{equation}
\f]

\f$ V^{t} \f$ is the vertex embedding in iteration \f$ t \f$. \f$ L \f$ we use here is the classic cotangent Laplacian operator introduced in \cgalCite{desbrun1999implicit}. \f$ W_{H} \f$ is a diagonal matrix, all diagonal element being equal and denoted as \f$ w_{H}\f$.  \f$w_{H}\f$ is a user parameter that controls the speed of MCF. Slowing down the MCF is essential since as the mesh evolves, the local curvature changes and the Laplacian operator needs to be updated to better approximate the mean curvature.

The effect of \f$ w_{H} \f$ is illustrated in \cgalFigureRef{WHeffect}.

\cgalFigureBegin{WHeffect, WHeffect.png}
From left to right, the \f$ w_{H} \f$ is 0.1, 0.05, 0.01, 0.005 respectively.  Note setting \f$ w_{H} \f$ too small results in a low quality of skeleton.  By default, the \f$ w_{H} \f$ is set to 0.1, which works well in most cases.
\cgalFigureEnd

\subsection MCFSkelSecRemesh Local Dynamic Remeshing

As shown in \cgalCite{tagliasacchi2012mean}, the MCF moves the surface points along the maximum principle curvature directions, which could result in very high aspect ratio triangles that stiffens the finite element solver. To address the problem, a local remeshing is performed at each iteration by collapsing short edges and split badly triangles while maintaining the manifold property.  Specifically, an edge \f$ e \f$ is split if in an incident triangle, the angle at the opposite vertex in the triangle is greater than \f$ 110^{\circ} \f$. The split point is the perpendicular projection of the opposite vertex onto \f$ e \f$.

\subsection MCFSkelSecDegeneracy Degeneracy Detection

As the mesh contraction process continues, the collapsed branches of the shape would be pulled away from the medial axis and the tips of the skeletal branches could be contracted back into the shape. We would like to stop the movement of points in a branch when a branch is detected. If we think of a branch as infinitesimal cross-sectional manifold, in the discrete case the problem is reduced to monitor the Euler characteristic of a point within a infinitesimal geodesic neighborhood. If the local neighborhood exhibits non-disk topology, we think the point is degenerate and fix it by setting the correspondent diagonal element in \f$ W_{H} \f$ as a very large number.

\subsection MCFSkelSecMedial Medial Skeletonization Flow

To compute a well-centered curve skeleton (i.e. one that lies close to the medial axis) we modify Eq.\f$\eqref{eq:regularized_equation}\f$ to:

\f[
\begin{equation}
  \left[\begin{array}{c}
  L\\
  W_{H}\\
  W_{P}
  \end{array}\right] 
  V^{t+1} = 
  \left[\begin{array}{c}
  0\\
  W_{H}V^{t}\\
  W_{P}P^{t}
  \end{array}\right] 
  \label{eq:medial_equation}
\end{equation}
\f]

Where the \f$ W_{P} \f$ is weights to control the smoothness of medial approximation and \f$ P^{t} \f$ is correspondent medial poles for each vertex.  During the collapse in local remeshing, we need to update the pole. In particular, we position the new vertex to the middle point of the collapsed edge and choose the closest pole from the poles of the two incident vertices of the edge.

\note To solve the spares linear system, Eigen 3.2 or later is recommended. Eigen is an open source library and easy to use.

\section MCFSkelSecAPI User Interface Description

The curve skeleton can be extracted by the free function `::CGAL::extract_skeleton`. This function could be used to extract a skeleton from the given mesh automatically without any user interaction. The main parameters for the algorithm is passed through the `::CGAL::SkeletonArgs` structure. The constructor of `::CGAL::SkeletonArgs` will initialize the parameters to their default values, which works well in most cases. By default the skeleton extracted is medially centered. The user can set `is_medially_centered` in `SkeletonArgs` to `false` to get a skeleton without guarantee to be medially centered. More details on how to use the free function can be found in the example code.

The class `::CGAL::MCF_Skeleton` is provided to allow the user to call the low level functions such as `::CGAL::MCF_Skeleton::contract_geometry` and `::CGAL::MCF_Skeleton::update_topology`. This gives the user full control of each step of the algorithm and very useful to develop an interative demo. The Polyhedron demo contains a plugin implemented based on the API from `::CGAL::MCF_Skeleton`. \cgalFigureRef{Demo} shows an example of an interative demo. In the example code, we show how to call those functions.

\cgalFigureBegin{Demo, demo.png}
A screenshot of the interactive demo.
\cgalFigureEnd

The algorithm also tracks the correspondence between skeleton points and input vertices.

The correspondent points for a skeletal vertex are original surface points that are collapsed onto the skeletal vertex. They are useful for tasks such as mesh segmentation. In \cgalFigureRef{Correspondence}, we visualize such relationship by connecting each skeletal point to its correspondent points.

\cgalFigureBegin{Correspondence, correspondence.png}
Every skeletal point is connected to its correspondent surface points.
\cgalFigureEnd

As a proof of concept, we show an example of doing mesh segmentation with the skeleton extracted by this package. In the Mesh Segmentation package from CGAL, the first step is computing a shape diameter value, and the second step is solving a graph cut problem. Here we use our skeleton to compute the the shape diameter value. Specifically we compute the diameter value for each face as the average distance between its three incident vertices and their corresponding skeletal point. Then we plug the diameter values into the graph cut algorithm from Segmentation package to get a continuous mesh segmentation. We show a sample segmentation in \cgalFigureRef{Segmentation}.

\cgalFigureBegin{Segmentation, segmentation.png}
On the left is the curve skeleton extracted from the mesh. On the right is the segmentation result utilizing the skeleton.
\cgalFigureEnd

\note Due to the remeshing step (the edge split) in the algorithm, a given skeleton point might have no corresponding surface point.

\subsection Skeletonization Examples

\subsubsection Example_1 Extract Skeleton With Free Function

In this example, we extract the skeleton automatically by using the provided free function.

\cgalExample{Mean_curvature_skeleton/simple_mcfskel_example.cpp}

\subsubsection Example_2 Extract Skeleton With `MCF_Skeleton` Class

In this example, we show how to use the API from `MCF_Skeleton` class.

\cgalExample{Mean_curvature_skeleton/MCF_Skeleton_example.cpp}

\subsubsection Example_3 Mesh Segmentation Based On The Skeleton.

In this example, we show how to do mesh segmentation with the extracted skeleton.

\cgalExample{Mean_curvature_skeleton/segmentation_example.cpp}
\section Performances

We use the elephant model as an example to evaluate the running time of different sizes of the models. Loop subdivision is performed on the model to increase the number of vertices. \cgalFigureRef{Comparison} shows the extracted skeleton for each model. From the result we can see the skeleton is not completely inside the mesh if the model is not sufficiently sampled. The reason is the Voronoi poles may contain noise if the sampling is not dense. As we increase the level of sampling, the quality of the poles improve and so is the skeleton.

\cgalFigureBegin{Comparison, comparison.png}
The left model is original mesh. The one in the middle is after one loop subdivision. The right one is after two loop subdivisions.
\cgalFigureEnd

We have recorded the running time of the algorithm. The CPU of the test machine is Intel(R) Core(TM) i5-3427U CPU @ 1.80GHz. According to the results, the running time grows linearly as the size of the mesh. This is very natural as the most expensive part of the algorithm is solving a sparse linear system and most sparse solvers have linear time complexity.

<center>
<table border="1">
<tr>
	<td> Number of vertices </td>
	<td> Time </td>
</tr>
<tr>
	<td> 2,775 </td>
	<td align='right'> 597ms </td>
</tr>
<tr>
	<td> 11,112 </td>
	<td align='right'> 1,943ms </td>
</tr>
<tr>
	<td> 44,460 </td>
	<td align='right'> 8,000ms </td>
</tr>
</table>
</center>

\section MCFSkelSecDesign Design and Implementation History

The initial implementation of this package is the result of the work of Xiang Gao during the 2013 season of the Google Summer of Code mentored by Andrea Tagliasacchi and Sébastien Loriot.

*/ 
} /* namespace CGAL */

